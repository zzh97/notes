### 学着学着就秃了的凸优化

#### Introduction

首先，我们聊几个概念，线性规划、最优化、凸优化、动态规划等

在国内，某些（应该是）经管类专业的学生会学习的一门课——叫**运筹学**

这门课就包含了上述的所有概念

但是，由于时间有限和本科阶段，所以大多数的学校，对于运筹学的课程设计，只包含了线性规划，而且着重于**单纯形法**

而，计算机专业的学生，在读研期间可能会学过一门课，叫**最优化理论**，或者干脆就叫凸优化，因为由于种种原因，大多数学校在最优化理论这门课中，不关注非凸的情况

我们这份笔记呢，主要研究的也是凸优化（虽然我算经管类的）



现在，我们来介绍这些概念

运筹学：取有“运筹帷幄之中，决胜千里之外”之意，不过我们根据它的英文名Operational Research，更能看出它的含义，运营研究，说白了， 就运用数学工具，对管理问题进行统筹规划

最优化：顾名思义，一门研究最优的学科，什么是最优，如何寻找最优等等，它的英文名是Optimization，最佳选择；最优化还有一个名字，叫数学规划Mathematical Programming，利用数学工具，选择最优

凸优化：最优化理论中的一种，是比较简单的最优化，因为**凸函数**具有良好的性质，使得其极值便是其最值，英文名Convex Optimization，约束条件与目标函数都是凸函数的最优化便是凸优化

约束规划：有约束条件的规划，反之便叫无约束规划，这块我们不涉及

线性规划：Linear Programming，约束条件与目标函数都是**线性函数**，即线性规划是凸优化中的一部分



不知道现在你对上述概念，是否了解，不了解也没关系，接下来我们会根据重点来详细阐述跟凸优化有关的内容

优化，便是从一堆可行解中，选择一个最优解，通俗而言，就是中一堆解决方案中，选择一个最佳方案

至于什么是最优，什么是最佳，就要视具体情况了（看需求）



#### Example

我们每天都会思考一个问题——等会吃啥？

还有十分钟就放学了，我现在还挺饿的

食堂里有两种主食，炒饭与拉面

炒饭8元，量大；拉面7元，有汤

如果吃炒饭，我需要再花4块钱买碗汤，如果吃拉面，一份吃不饱，需要再吃一份

假设我是一个穷B，现在，给出你的答案，等会吃啥？  



首先，列出题目中的条件（称其为**约束条件**Constraint equations）以及会得出的结果（称其为**目标函数**Goal function）

设x为炒饭的数量，y为拉面的数量
$$
Constraint\ equations:\begin{cases}
x \geq 0,\ y \geq 0\\
x+\frac{1}{2}y \geq 1\\
\end{cases}
\quad Goal\ function:f=\begin{cases}
8x+7y+4,\ y < 1\\
8x+7y,\ y\geq 1\\
\end{cases}
$$
这是一个比较简单的中学问题，通过画图就能解决

<img src="D:\zzh\demome\笔记\cp_img\1.png" style="zoom:50%;" />

在可行域（可行解集）中，我们可以找到两个顶点（标红的点），其中便有最优解（在线性规划中，顶点往往是最优解）

把顶点坐标带入目标函数，求得，一个是8+4=12，另一个是7*2=14

因为我很穷，故求最小值，min{12, 14}，则最优解是(1, 0)，需要花12元



好，我们现在稍微地，把问题抽象一点，拔高一点，如果你上了大学，学过线性代数的话

任何一个优化问题，我们都可以把它抽象成
$$
从m个n维的可行解中，找到使得f最小的最优解\\
\min \{f(X)\},\ X=(x_1, x_2, \cdots, x_m),\ x_i=(x_{i1}, x_{i2}, \cdots, x_{in})^T\\
即\min \{f(X)\},\ X=\begin{bmatrix}
x_{11} & x_{12} & \cdots & x_{1n}\\
x_{21} & x_{22} & \cdots & x_{2n}\\
\cdots\\
x_{m1} & x_{m2} & \cdots & x_{mn}\\
\end{bmatrix}\\
m是可行解的个数，n是解的维数
$$
Max情况同理



如果它是一个约束规划，即带有约束条件

那么这个约束条件也可以抽象成
$$
\begin{cases}
g_1(x_{11},\ x_{12},\ \cdots,\ x_{1n}) \leq b_1\\
g_2(x_{21},\ x_{22},\ \cdots,\ x_{2n}) \leq b_2\\
\cdots\\
g_2(x_{m1},\ x_{m2},\ \cdots,\ x_{mn}) \leq b_m\\
\end{cases}\quad 即g(X)\leq b\\
m是约束条件的个数
$$
大于等于时同理



如果约束条件是等于呢？

答，所有的等式都能写成不等式，所以是一样的



#### Linear Programming





#### Dynamic Programming

还是以一个例子开头

我们都知道，软妹币有1元的，5元的，10元的

假设现在要拿出17元，请问怎么拿，需要的张数最少



这很简单啊，想看面额最大的10元需要几张，减去它后，再看5元，以此类推：
$$
17\div 10=1余7,\ 需要1张10元 \\
7\div 5=1余2,\ 需要1张5元 \\
2\div 1=1余0,\ 需要2张1元 \\
$$
故，最少需要4张货币



上述的便是计算机里的**贪心算法**——在求解过程中，总是选择在当下最佳的选项

看起来是很简单，那是因为，软妹币的面额设置的很妥当

假设，面额变成了1元、5元、10元与13元

请问，要怎么拿出张数最少的17元呢？



此时，如果继续使用贪心算法：
$$
17\div 13=1余4,\ 需要1张13元\\
4\div 10=0余4,\ 需要0张10元\\
4\div 5=0余4,\ 需要0张5元\\
4\div 1=4余0,\ 需要4张1元\\
$$
故，最少需要5张



诶，不对呀，我们明明只是增加了一张13元面额的软妹币，怎么需要的张数反而变多了呢？

这便是贪心算法的弊端——目光短浅，只管当下的最佳选项，不管下一步的情况，导致整体选择并非最优



所以，我们应该用长远的眼观，动态的视角来看问题，不能犯资本主义短视性的错误

![](D:\zzh\demome\笔记\cp_img\2.png)

我们定义一个函数，来描述下一步的情况

```
def next (要拿的钱, 当前选择的面额):
	return (需要的张数, 下一步的最佳面额)
```



对于上述问题：

```
next (17,13) = (1, 1) // 要拿17元的情况下，选择了13元的货币，需要1张，下一步就只能选择1元的货币
next (17,10) = (1, 5) // 要拿17元的情况下，选择了10元的货币，需要1张，下一步就只能选择5元的货币
```



